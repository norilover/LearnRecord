# Redis
> 单线程Redis的高性能

```tex
Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。
单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点
```

> Redis 避免数据丢失的办法
```
AOF :
    Always
        每次命令执行
    Everysec
        每秒执行    
    No
        交给操作系统

Aop文件过大，将导致恢复时超长
Redis 还提供了 AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞。

RDB:
    就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。
    这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写

联合解决方案：
    混合使用AOF日志和RDB 
        先做一次全量快照 -> AOF日志记录 -> 等移动时间在做全量快照 -> 清空上次AOF日志记录，开始再次记录 -> ...
```

> 在应对数据量扩容时
```text
纵向扩展:
    简单直接，导致内存过大，性能下降
横向扩展
    Redis 切片集群提供的横向扩展.
    也就是使用多个实例 -> 并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，
        -> 再通过哈希槽分散保存到不同的实例上。
    这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。
    
命令：
    MOVED :
        client发送一个键值对操作，通过查找缓存中保存哈希槽(slot)信息, 确定给那个Redis实例
            -> 该实例是否存在该键值对
                -> if 存在
                     ->执行键值对操作
                -> if 不存在（由于负载均衡，slot发生迁移）
                    -> 发送MOVED命令， 将slot对应的实例告诉客户端
                        EG.
                            Get key_name : key
                            MOVED 13320 172.16.19.5:6379
                        -> 客户端再次发送请求完成操作
                        -> 客户端更新缓存中的slot信息
    
    ASK:
    ASKING:
        client 发送一个键值对操作，通过查找缓存中保存的哈希槽(slot)信息, 确定给Redis实例1
            -> 但该slot正在发生迁移, 从实例1迁移到实例2    
            -> if 实例1查找发现需要查找的slot对应内容已经迁移到实例2
                -> 发送ASK命令给client
                    EG.
                        Get key_name : key
                        MOVED 13320 172.16.19.5:6379
                        
                    -> client发送ASKING命令
                    -> 客户端再次发送请求完成操作
                    -> 不更新缓存中的slot信息
         
```

> 二进制安全
>  只存字节流 
> 
 
> 类型
```java
    
    list
    set
    sorted set
        排序实现：skip list  log2 n 
    
```